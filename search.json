[{"title":"electron初体验","url":"/2025/07/17/electron%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"背景近期因为一些原因，需要频繁切换网络环境，每次切换环境都需要拔插网线或者是从控制面板中禁用网卡。不喜欢这种重复的无意义操作，便寻思可以写个脚本调用方法来切换网卡状态，于是先整了个脚本，但是每次还需要双击运行，而且无法直观地看到两个网卡当前的状态，又想到或许可以用electron构建个app，用js调用api来切换网卡状态，遂跟gpt老师进行了一番探讨，成功写了个小软件实现实时监控网卡状态+一键切换网络环境的功能。\n软件样式设计输入需求让gpt老师帮忙画了个设计图，最终实现效果如下：\n\n\n代码实现有了设计图就可以开工了，由于对electron并不了解，让gpt先帮忙搭了个框架。\n项目结构network-switch-app/├── main.js              // 主进程：窗口创建、状态检测、指令执行├── preload.js           // 预加载脚本（可用于暴露安全 API）├── renderer/            // 渲染进程│   ├── index.html│   ├── renderer.js├── assets/│   └── icon.ico         // 应用图标├── config.json          // 网卡名配置文件（intranet/internet）├── package.json\n\nmain.js 中开启程序窗口以及调用系统API，preload.js 中挂载全局方法，在renderer中实现页面内容以及js逻辑处理\n主进程 main.js 核心功能1. 创建窗口const win = new BrowserWindow(&#123;  width: 280,  height: 160,  useContentSize: true,  frame: false,  alwaysOnTop: true,  resizable: false,  transparent: true,  webPreferences: &#123;    preload: path.join(__dirname, &#x27;preload.js&#x27;),    contextIsolation: true,    nodeIntegration: false,  &#125;,  icon: path.join(__dirname, &#x27;assets&#x27;, &#x27;icon.ico&#x27;),&#125;)\n\n2.读取可编辑的配置文件const configPath = path.join(path.dirname(app.getPath(&#x27;exe&#x27;)), &#x27;config.json&#x27;)const config = JSON.parse(fs.readFileSync(configPath, &#x27;utf-8&#x27;))\n\n3. 执行网络切换（Windows）exec(`netsh interface set interface name=&quot;$&#123;name&#125;&quot; admin=ENABLED`)\n\n4. 获取网卡状态const getAdapterStatus = (name) =&gt;  new Promise((resolve) =&gt; &#123;    exec(      `powershell -Command &quot;(Get-NetAdapter -Name \\\\&quot;$&#123;name&#125;\\\\&quot; -ErrorAction SilentlyContinue).Status&quot;`,      (err, stdout) =&gt; &#123;        const status = stdout.trim()        resolve(status === &#x27;Up&#x27; ? &#x27;Up&#x27; : &#x27;Down&#x27;)      &#125;    )  &#125;)\n\nAPI串联1. main.js：主进程注册功能// 网卡状态检查ipcMain.handle(&#x27;get-status&#x27;, async () =&gt; &#123;&#125;)// 切换模式ipcMain.handle(&#x27;toggle-mode&#x27;, async () =&gt; &#123;&#125;)\n\n2. preload.js：暴露 API 的桥梁const &#123; contextBridge, ipcRenderer &#125; = require(&#x27;electron&#x27;)contextBridge.exposeInMainWorld(&#x27;networkAPI&#x27;, &#123;  getStatus: async () =&gt; await ipcRenderer.invoke(&#x27;get-status&#x27;),  toggleMode: async () =&gt; await ipcRenderer.invoke(&#x27;toggle-mode&#x27;)&#125;)\n\n3. renderer.js：渲染进程使用 APIasync function updateStatus() &#123;  const status = await window.networkAPI.getStatus()&#125;\n\n打包构建&quot;build&quot;: &#123;  &quot;appId&quot;: &quot;com.fbz.networkswitch&quot;,  &quot;productName&quot;: &quot;内外网切换器&quot;,  &quot;files&quot;: [    &quot;main.js&quot;,    &quot;preload.js&quot;,    &quot;renderer/**/*&quot;,    &quot;config.json&quot;  ],  &quot;extraFiles&quot;: [    &#123;      &quot;from&quot;: &quot;config.json&quot;,      &quot;to&quot;: &quot;config.json&quot;    &#125;  ],  &quot;directories&quot;: &#123;    &quot;buildResources&quot;: &quot;assets&quot;,    &quot;output&quot;: &quot;dist&quot;  &#125;,  &quot;win&quot;: &#123;    &quot;target&quot;: &quot;nsis&quot;,    &quot;icon&quot;: &quot;assets/icon.ico&quot;,    &quot;sign&quot;: false  &#125;,  &quot;nsis&quot;: &#123;    &quot;oneClick&quot;: false,    &quot;perMachine&quot;: true  &#125;&#125;\n\n注意事项：\n\nwin图标需要使用多分辨率图标，16x16, 32x32, 48x48, 256x256 都包含在 .ico 文件中。（在线转换工具: https://www.aconvert.com/cn/icon/png-to-ico/）\n\n结语之前也有想研究electron，但是一直没什么契机，这次刚好遇到这种需求，便借着chatgpt写了个小工具，也算是对其有了初步的认知，使用electron前端开发也能快速上手开发程序了。待下一次有新想法的时候，再深入研究研究\n","categories":["技术笔记"],"tags":["electron"]},{"title":"Hello World","url":"/2021/06/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new posthexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun serverhexo server\n\nMore info: Server\nGenerate static fileshexo generate\n\nMore info: Generating\nDeploy to remote siteshexo deploy\n\nMore info: Deployment\n"},{"title":"hexo的使用","url":"/2025/07/07/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"背景前几年搭建了博客，但是一直都没有投入编写内容，最近又捡起来重新折腾了一下，重新梳理了一下hexo的使用，加深了理解，在此记录一下做个备忘。\n一、安装与使用1. 安装 Hexo CLInpm install -g hexo-cli\n\n2. 初始化博客项目hexo init blogcd blognpm install\n\n3. 安装并启用主题个人喜欢Next主题的样式，因此这里选用Next主题\n# 使用npm安装主题npm install hexo-theme-next# 拷贝配置文件到根目录cp node_modules/hexo-theme-next/_config.yml _config.next.yml\n\n修改_config.yml中的theme，以启用next主题\nHexo config filetheme: next\n\n可以在_config.next.yml中修改scheme以切换系统样式，个人喜欢gemini的设计\nNext config filescheme: Gemini\n\n4. 创建文章hexo new &quot;文章标题&quot;\n\n生成文件位于：source/_posts/文章标题.md\n5. 本地预览hexo server\n\n访问：http://localhost:4000 进行本地预览\n二、推荐插件1. hexo-generator-sitemap部署&#x2F;运行时会生成sitemap\n执行npm i hexo-generator-sitemap安装\n并在配置文件_config.yml中添加以下配置，重新编译运行并访问http://localhost:4000/sitemap.xml即可看到网站地图的输出了\nHexo config filesitemap:  path: sitemap.xml\n\n2. hexo-generator-searchdb开启本地搜索功能\n执行npm i hexo-generator-searchdb安装\n并在配置文件_config.yml中添加以下配置，重新编译运行后点击菜单栏的“搜索”按钮，即可搜索站内博客\nHexo config filesearch:  enable: true\n\n三、部署与SEO优化部署方案一开始采用GitHub托管，有提交自动触发构建并部署，然后域名解析到GitHub部署页面的方案。但是由于gfw，墙内访问比较困难（公司破网挂不挂梯子都很难打开自己的博客），且添加评论时，会遇到跨域问题不好解决。遂改为在服务器上打包构建，用nginx部署。\n在服务器上拉取仓库并执行npm i安装依赖，在仓库根目录创建部署脚本deploy.sh\ndeploy.sh#!/bin/bashecho &quot;🔄 拉取最新代码...&quot;cd /home/webapps/bloggit pull origin mainecho &quot;📦 安装依赖...&quot;npm installecho &quot;🧹 清理旧生成文件...&quot;npx hexo cleanecho &quot;📝 生成静态文件...&quot;npx hexo generate\n\n输入bash /path/to/deploy.sh即可执行部署脚本自动打包构建。\n证书申请配置nginx之前，还需要注册一下证书以开启https协议。\n首先确保/etc/ssl/certs、/etc/ssl/private目录存在，若不存在，执行以下命令创建目录并赋予权限\nmkdir -p /etc/ssl/privatechmod 700 /etc/ssl/privatemkdir -p /etc/ssl/certschmod 700 /etc/ssl/certs\n\n执行以下命令签发证书，指定letsencrypt服务可以不用注册邮箱，且支持自动续期\n# 先停止nginx服务bt stop nginx# 签发证书acme.sh --issue --standalone -d your.domain.com --ecc --server letsencrypt# 安装证书，最后的reloadcmd修改为本机重载ng配置的指令，我用宝塔面板安装的，因此执行bt reload nginxacme.sh --install-cert -d your.domain.com --ecc \\  --key-file       /etc/ssl/private/your.domain.com.key \\  --fullchain-file /etc/ssl/certs/your.domain.com_bundle.crt \\  --reloadcmd     &quot;bt reload nginx&quot;# 重载nginxbt reload nginx\n\nnginx配置接下来在nginx配置中添加以下配置，再重载即可访问部署后的博客页面了\nnginx.confserver &#123;  listen 80;  server_name your.domain.com;  # 强制跳转到 HTTPS  return 301 https://$host$request_uri;&#125;server &#123;  listen 443 ssl;  server_name your.domain.com;  # SSL 证书路径（你需要替换成自己的）  ssl_certificate /etc/ssl/certs/your.domain.com_bundle.crt;  ssl_certificate_key /etc/ssl/private/your.domain.com.key;  ssl_session_timeout 5m;  ssl_protocols TLSv1.2 TLSv1.3;  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5;  ssl_prefer_server_ciphers on;  root /path/to/博客仓库/public;  index index.html;  access_log /www/wwwlogs/access_blog.log;  location / &#123;    try_files $uri $uri/ /index.html;  &#125;&#125;\n\nSEO优化SEO优化比较复杂，只是记录下自己做过的操作，还在研究学习中。\n以谷歌搜索为例，访问地址：https://search.google.com/search-console，输入要索引的域名，谷歌会返回一个校验码文件。创建一个静态文件目录source/static存放这个文件。\n并在hexo配置文件中添加跳过渲染内容，避免部署后访问校验文件时出现内容嵌套在博客框架中，导致校验不通过的问题。重新打包并访问https://your.domain.com/googledxxxxxxxxxx应该能看到输出google-site-verification: googledxxxxxxxxxx.html。\n_config.ymlskip_render:  - static/**/*\n\n站点验证成功后还需要添加一下sitemap，这样谷歌可以知道需要抓取的子页面有哪些。若安装了上文的sitemap插件，可在ng添加如下配置，访问https://your.domain.com/sitemap时即可直接重定向到https://your.domain.com/sitemap.xml\n...location / &#123;  try_files $uri $uri/ /index.html;&#125;location = /sitemap &#123;  return 301 /sitemap.xml;&#125;\n\n然后在谷歌控制台中找到并打开“站点地图”菜单栏，在“添加新的站点地图”中输入sitemap，点击提交即可。\n四、开启站内评论这里选用twikoo作为站内评论组件 (需要next主题8.x版本支持)\n先在服务器上启动服务，访问ip:port若看到输出Twikoo 云函数运行正常，请参考 https://twikoo.js.org/frontend.html 完成前端的配置 则为启动成功了\ndocker run -d \\  --name twikoo \\  -e TZ=Asia/Shanghai \\  -e TWIKOO_THROTTLE=10 \\  -v /home/twikoo/data:/app/data \\  -p 8080:8080 \\  --restart=always \\  imaegoo/twikoo\n\n为了避免跨域，这里用nginx把twitoo代理转发到跟博客同域名下，在nginx博客配置部分添加如下内容\n...location / &#123;  try_files $uri $uri/ /index.html;&#125;# 👇 添加 Twikoo 的反向代理配置location /twikoo/ &#123;  proxy_pass http://127.0.0.1:8080/; # 修改为twikoo服务的端口  proxy_set_header Host $host;  proxy_set_header X-Real-IP $remote_addr;  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;\n\n然后在博客根目录执行npm i hexo-next-twikoo安装twikoo组件，在next配置文件中添加如下配置，重新打包部署后访问博客页面应该就能看到站内评论组件了\n_config.next.yml# Multiple Comment System Supportcomments:  # Available values: tabs | buttons  style: tabs  # Choose a comment system to be displayed by default.  # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances  active: disqus  # Setting `true` means remembering the comment system selected by the visitor.  storage: true  # Lazyload all comment systems.  lazyload: false  # Modify texts or order for any naves, here are some examples.  nav:    twikoo:      order: -1      text: Twikoo 评论    disqus:     text: Load Disqus     order: -1    #gitalk:    #  order: -2twikoo:  enable: true  envId: https://your.domain.com/twikoo  # 或 http://ip:port，改成你自己的地址  region: &#x27;&#x27;  path: window.location.pathname  visitor: true  commentCount: true\n\n五、一些问题1. 图片引入问题配置文件中设置post_asset_folder: true，这样在创建博客时会生成博客同名的文件夹，便于管理图片，一开始尝试markdown原生的图片引入写法![图片alt](图片链接 &quot;图片title&quot;)最终渲染出来的图片路径始终不对，一番研究发现用&#123;% asset_img 图片文件名 描述文字 %&#125;这个标签才能成功渲染出实际路径\n","categories":["技术笔记"],"tags":["HEXO"]},{"title":"PDF批量转图片","url":"/2025/06/24/pdf%E6%89%B9%E9%87%8F%E8%BD%AC%E5%9B%BE%E7%89%87/","content":"背景最近在做一个项目，需要在弹窗里展示政策PDF内容。本来想着直接把PDF文件放在前端项目里，但一个文件大几十M，加载起来很慢。而且客户不想看到PDF在网页中的预览框。考虑到只是展示内容，不需要交互功能，就想着把PDF转成图片，这样既能缩小文件体积，又能提升加载速度。\n解决方案经过一番搜索，发现 ImageMagick 是个不错的选择。它不仅能处理PDF转图片，还支持批量处理，正好符合我的需求。\n工具准备\n安装 ImageMagick\n\nWindows: 下载安装包或使用 choco install imagemagick\n安装后记得重启命令行\n\n\n验证安装\nmagick --version\n\n安装ImageMagick底层依赖 Ghostscript\n\n下载适合系统版本的安装包（通常是 gswin64.exe）\n\n\n验证安装\ngswin64c -version\n\n批量转换脚本为了方便使用，我写了个批处理脚本，支持批量转换PDF文件：\n@echo offsetlocal enabledelayedexpansion:: 设置目标 DPI，调整这里即可改变分辨率set dpi=150:: 设置输出图片的质量（范围：1-100）set quality=80:: 定义 A4 的实际尺寸（单位：英寸）set a4_width_inch=8.27set a4_height_inch=11.69:: 使用 PowerShell 动态计算 A4 分辨率（宽度和高度）for /f &quot;tokens=*&quot; %%A in (&#x27;powershell -Command &quot;[math]::Round(%a4_width_inch% * %dpi%)&quot;&#x27;) do set width=%%Afor /f &quot;tokens=*&quot; %%A in (&#x27;powershell -Command &quot;[math]::Round(%a4_height_inch% * %dpi%)&quot;&#x27;) do set height=%%A:: 输出宽高以及质量参数以供验证echo DPI: %dpi%echo Width: %width% pixelsecho Height: %height% pixelsecho Quality: %quality%%:: 验证宽高是否正确if &quot;%width%&quot;==&quot;&quot; (    echo 宽度计算失败，请检查 PowerShell 是否可用或计算逻辑是否正确。    pause    exit /b)if &quot;%height%&quot;==&quot;&quot; (    echo 高度计算失败，请检查 PowerShell 是否可用或计算逻辑是否正确。    pause    exit /b):: 遍历当前目录中的所有 PDF 文件for %%f in (*.pdf) do (    :: 获取文件名（不带扩展名）    set filename=%%~nf    :: 创建与 PDF 同名的输出目录    mkdir &quot;!filename!&quot;    :: 转换 PDF 为图片，确保背景为白色，大小统一，设置质量    magick -density %dpi% &quot;%%f&quot; -background white -alpha remove -alpha off -resize %width%x%height% -gravity center -extent %width%x%height% -quality %quality% &quot;!filename!\\page-%%d.webp&quot;)echo 转换完成！pause\n\n使用心得参数调优经验\nDPI设置：\n\n150 DPI：适合大多数场景，文件大小和质量比较平衡\n200 DPI：高清显示，文件稍大\n100 DPI：文件最小，但可能不够清晰\n\n\n质量设置：\n\n80-90：推荐设置\n70以下：文件小但质量一般\n95以上：质量好但文件大\n\n\n\n效果对比转换后的文件结构：\n项目/├── convert_pdf_to_images.bat├── 政策文件.pdf└── 政策文件/    ├── page-0.webp    ├── page-1.webp    └── ...\n\n文件大小对比：\n\n原PDF：41.6MB\n转换后：约5.3M（WebP格式）\n压缩率：约87%\n\n总结这个方案在一定程度上解决了我的问题：\n\n✅ 1M以上的文件体积基本都大幅压缩了\n✅ 加载速度明显提升\n✅ 保持了良好的显示效果\n✅ 支持批量处理，效率高\n\n对于类似的需求，我觉得这个方案还是挺实用的。如果只是展示内容，转成图片确实比直接使用PDF要好很多。\n\n记录一下这个实用的解决方案，以后遇到类似需求可以直接用。\n","categories":["技术笔记"],"tags":["PDF转图片","前端优化","实用工具"]},{"title":"网页适老化","url":"/2025/06/25/%E9%80%82%E8%80%81%E5%8C%96/","content":"背景最近在做的项目有老年人模式的需求——也就是动态切换字体大小、元素间距等。\n解决方案项目使用element-ui、sass、sass-loader，在scss文件中定义变量，并利用:export导出变量，供JS使用。JS中读取变量，使用setProperty方法设置全局css变量。项目中所有需要动态改变大小的，都不直接使用px，而是使用css变量进行设置。\n使用开关动态切换常规&#x2F;老年人模式变量，以切换全局css变量值。\n以下是代码的实现：\n目录结构src├── styles│   ├── index.scss│   ├── variables.scss│   └── variables-senior.scss└── App.vue\n\n关键代码/* variables.scss *//* 无需动态改变的常量 */$main_color: #4077f4;// .../* 差异化变量 */$variables: (  // 字号  font_size_extra_large: 20px,  font_size_large: 18px,  font_size_medium: 16px,  font_size_base: 14px,  font_size_small: 13px,  font_size_extra_small: 12px,  // checkbox  checkbox_after_left: 4px,  checkbox_after_top: 1px,  // 表单项  form_item_margin_bottom: 16px,  search_btn_width: 70px,  search_btn_detail_width: 60px);:export &#123;  /* 常量部分 */  main_color: $main_color;  // ...  /* 变量自动导出 */  @each $name, $value in $variables &#123;    #&#123;$name&#125;: #&#123;$value&#125;;  &#125;&#125;\n\n/* variables-senior.scss */// 字体增量，可以统一控制放大倍率$font_size_increment: 5px;/* 差异化变量 */$variables: (  // 字号  font_size_extra_large: 20px + $font_size_increment,  font_size_large: 18px + $font_size_increment,  font_size_medium: 16px + $font_size_increment,  font_size_base: 14px + $font_size_increment,  font_size_small: 13px + $font_size_increment,  font_size_extra_small: 12px + $font_size_increment,  // checkbox  checkbox_after_left: 6px,  checkbox_after_top: 3px,  // 表单项  form_item_margin_bottom: 24px,  search_btn_width: 80px,  search_btn_detail_width: 80px);:export &#123;  /* 变量自动导出 */  @each $name, $value in $variables &#123;    #&#123;$name&#125;: #&#123;$value&#125;;  &#125;&#125;\n\n&lt;!-- 有的元素不能仅用变量控制，这时候就需要使用class .senior-mode，调整元素在老年人模式下的表现 --&gt;&lt;template&gt;  &lt;div id=&quot;app&quot; :class=&quot;&#123; &#x27;senior-mode&#x27;: isSeniorMode &#125;&quot;&gt;    &lt;el-switch v-model=&quot;isSeniorMode&quot; @change=&quot;toggleMode&quot;&gt;      老年人模式    &lt;/el-switch&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import normalVariables from &quot;@/styles/variables.scss&quot;import seniorVariables from &quot;@/styles/variables-senior.scss&quot;export default &#123;  name: &quot;app&quot;,  data() &#123;    return &#123;      isSeniorMode: false,    &#125;  &#125;,  mounted() &#123;    this.setMode()  &#125;,  methods: &#123;    toggleMode() &#123;      this.setMode(this.isSeniorMode)    &#125;,    setMode(isSenior = false) &#123;      const vars = isSenior ? seniorVariables : normalVariables      for (const [key, value] of Object.entries(vars)) &#123;        document.documentElement.style.setProperty(`--$&#123;key&#125;`, value)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;\n\n/* style/index.scss */.el-button &#123;  font-size: var(--font_size_base);  &amp;--mini &#123;    font-size: var(--font_size_extra_small);  &#125;  &amp;--small &#123;    font-size: var(--font_size_base);  &#125;  &amp;--medium &#123;    font-size: var(--font_size_medium);  &#125;&#125;\n\n结语这个方案的效果还是比较满意的，衍生出来还可以封装成组件，实现大中小三种字号切换的模式\n","categories":["技术笔记"],"tags":["老年人模式","动态调整字体大小"]}]